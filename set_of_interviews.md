# ---------------------------------------------
#### 面试
## 不同类型题目
### 考点内容
题号前 + '*'代表未完成，+ '!'代表要回顾
#### 为大类    ### 为细分类别
优先级：
项目 -> 语言基础 -> 计算机基础 -> 算法
# ---------------------------------------------




#### 项目
# ---------------------------------------------
## 1.微服务器:SpringCloud, SpringBoot, Dubbo

## 2.分布式服务框架：Zookeeper

## 3.消息队列：Kafka, RabbitMQ, RocketMQ

## 4.内存数据库：Memcached, Redis

## 5.分布式搜索引擎：Solr, Lucene, ES




#### 语言基础
# ---------------------------------------------
### 1.Javase
(1)Java实现生产者和消费者的三种方法
(2)init方法与clinit方法的区别
反射机制
(3)Java中的引用
(4)Java对象的创建过程
(5)Java中创建子类实例时会创建父类实例？
(6)Java的类加载机制 为什么会出现锁机制？
(7)抽象类和接口的区别
(8)双亲委派模型：启动加载器、扩展加载器、应用程序加载器
(9)重载与重写
(10)Java的类型擦除
(3)简述Java Object类中的方法有哪些
(3)char可以存储汉字嘛？
(3)抽象类和接口的区别
(3)静态分派与动态分派
(3)HashMap与HashTable的区别
(3)什么时候使用HashMap？它有什么特点？
(3)HashMap的基本原理及内部数据结构
(3)HashMap的put和get操作
(3)简述Java中的深拷贝与浅拷贝，C++中的浅拷贝和深拷贝
(3)解释一下static块和static变量的执行顺序
(3)equals()的重写规则
(3)Java中如何创建线程？
(3)JDK1.8新特性

### 2.集合源码
排序算法比较
Hashmap是线程安全的吗?为什么？
ArrayList与LinkedList区别
HashMap、LinkedHashMap和TreeMap
冒泡排序的优化以及快排过程及优化
红黑树
JDK7与JDK8中hashmap的区别
hashmap的初始容量为什么设置为16？
平衡二叉树的插入删除操作

### 3.JVM
JVM内存布局
JVM垃圾回收机制
JVM垃圾回收算法
哪些对象在老年代？
从年轻代到老年代执行的时间以及发生转移的场景
为什么存在GC？
简单可达性分析
Minor GC安全检查
垃圾回收器
引用记数法和可达性算法
类加载机制过程
双亲委派模型
双亲委派机制

### 4.多线程
锁分段技术、ConcurrentHashMap、扩容
Java同步线程有哪些方式？
volatile 和 synchronized的区别
讲一下同步异步（进程和IO）
synchronized和volatile的区别？
线程安全
对象的内存布局
哪些是线程安全的容器？
ConcurrentHashMap介绍
线程启动start和run
HashMap为什么线程不安全？
简述Java内存模型的happen before原则
volatile的原理和实现机制 || volatile到底如何保证可见性和禁止指令重排序的？
volatile关键字的两层语义 || 可见性
volatile保证原子性吗？
volatile能保证有序性吗？

### 5.IO




#### DB
# ---------------------------------------------




#### 计算机基础
# ---------------------------------------------
### 1.数据库


### 2.计算机网络
1.简述TCP和UDP的区别
TCP是传输控制协议，提供面向连接、可靠的字节流服务。客户和服务器交换数据之前必须建立TCP连接才能传输数据。TCP提供超时重发、丢弃重复数据、校验数据、流量控制等功能。保证数据传输成功。
UDP是用户数据协议，一个面向数据报的运输层协议。UDP不提供可靠性，只是把应用程序传给IP层的数据报发送出去，不保证传输成功。UDP传输之前不需要客户端和服务器建立连接，且没有超时重发机制，所以传输速度很快。
举例，TCP像打电话，要有通路，对方不接就会等，接收有先后顺序；UDP像寄信，只管发，不管收；发信者收信者没有通路；先发未必先到，后发未必后到，还有可能不到。


2.七层协议每一层的任务及作用
①物理层；
②数据链路层：将数据分帧，并处理流控制。指定拓扑结构并提供硬件寻址；
③网络层：为数据在点对点之间传输建立逻辑链路，并分组转发数据包；
④传输层：选择传输协议并添加协议头如TCP,UDP,SPX;
⑤会话层：定义会话的开始、控制和结束；
⑥表示层：定义数据格式及加密；
⑦应用层：为应用程序提供接口和通信服务；


3.简述http状态码
①网页应用在接收和解释请求消息后服务器会返回一个HTTP响应消息，由三部分组成：状态行、消息报头、响应正文；
格式如：HTTP-Version(服务器HTTP协议版本) Status-Code(响应状态代码) Reason-Phrase(状态代码的文本描述) CRLF
②状态码由三个数字组成，第一个数字代表响应类别，分组如下：
1XX：指示信息--请求已接收，继续处理；
2XX：成功--请求已被成功接收、理解、接受；
3XX：重定向--要求完成请求必须进行进一步的操作；
4XX：客服端错误--请求有语法错误或无法实现；
5XX：服务器端错误--服务器未能实现合法的请求；
③常见状态码、描述及说明：
200 OK：客户端请求成功；
400 Bad Request：客户端请求有语法错误；
401 Unauthorized：请求未经授权；
403 Forbidden：服务器收到请求，但拒绝服务；
404 Not Found：请求资源不存在；
500 Internal Server Error：服务器发生不可预期的URL；
503 Server Unavailable：服务器当前不能处理客户端的请求；


4.简述http协议与https协议
https需要到ca申请证书，需要一定费用；
http是超文本传输协议，信息是明文传输；https这是具有安全性的ssl(Secure Sockets Layer)加密传输协议；
http和https使用完全不同的连接方式和端口。前者是80，后者是443；
http连接简单，是无状态的；https协议是由SSL+HTTP协议构建的可加密传输、身份认证的网络协议。


5.简述SSL协议
SSL介于应用层和TCP层之间，应用数据不再直接传给传输层，而是传递给SSL层。SSL层会对数据进行加密并加上SSL头，是网络传输层之上提供的一种基于RSA的对称加密算法。
RSA算法基于一个数论事实：计算两个大素数的乘积很容易，但对乘积进行因式分解却很难，因此可以将乘积公开作为加密密匙。


6.解析DNS过程
①DNS全称Domain Name System，即域名系统。是因特网上作为域名和IP地址相互映射的一个分布式数据库，能够让用户方便地通过域名而不是服务器识别需要的IP地址访问网站。
②DNS有两种查询方法：一种是递归查询，客户端询问的本地域名服务器若不知道被查询域名的IP地址，本地域名服务器会以DNS客户身份向顶级域名服务器继续查询，知道找到再层层传递回来；第二种是迭代查询，客户端根据顶级服务器返回的其他DNS服务器，不断地询问知道找到为止。
③DNS查询过程中，客户端和服务器都会加入缓存机制，减少查询次数。所以浏览器输入要访问网站域名时，操作系统先检查本地hosts文件是否有这个网址的映射关系，没有再询问DNS服务器和其他顶级服务器，知道完成域名解析。


7.三次握手，四次挥手的过程？？为什么三握？？
https://juejin.im/post/6844903958624878606
①三次握手
○三次握手指建立一个TCP连接时，需要客户端和服务器总共发送三个包。进行三次握手的主要作用是为了确认双方的接受能力和发送能力是否正常、指定自己的初始化序列号为后续可靠性传递做准备。实质上就是连接服务器指定端口，建立TCP连接，同步连接双方的序列号和确认号，交换TCP窗口大小信息。
○具体流程：
刚开始客户端处于closed状态，服务端处于listen状态。进行三次握手：
○第一次握手：客户端给服务端发一个SYN报文，指明客户端的初始化序列号ISN(c)。此时客户端处于SYN_SEND状态。
首部的同步位SYN=1，初始序号seq=x，SYN=1的报文段不能携带数据，但要消耗一个序号。
○第二次握手：服务器收到客户端SYN报文后，会以自己的SYN报文作答，也指定了自己的初始化序列号ISN(s)。同时将客户端的ISN+1作为ACK的值，表示已收到客户端的SYN，此时服务器处于SYN_RCVD状态。
确认报文段中SYN=1，ACK=1，确认号ack=x+1，初始序号seq=y。
○第三次握手。客户端收到SYN报文后，同样会发送一个ACK报文，把服务器的ISN+1作为ACK值返回，表示已经收到服务端的SYN报文。此时客户端处于ESTABLISHED状态，服务器收到ACK报文后，也处于ESTABLISHED状态。此时，双方已建立起连接。
确认报文段ACK=1，确认号ack=y+1，序号seq=x+1(初始为x，第二个报文段要+1)。ACK报文段不携带数据则不消耗序号。
在socket编程中，客户端执行connect()时，将触发三次握手。

○需要三次握手的原因：
第一次握手：服务端确认客户端的发送能力、服务端的接收能力正常；
第二次握手：客户端确认：服务端的接收、发送能力正常，客户端的接收、发送能力也正常。但服务端不确定客户端的接收能力是否正常；
第三次握手：服务端确认客户端的接收能力正常(或者说客户端需要接受数据)。客户端的接收、发送能力也正常。
因此需要三次握手才能达到要求。如果只需要两次握手，有可能出现以下问题：客户端发出连接请求，因为延迟未收到确认，客户端重发一次。后来收到确认建立连接，传输完成就释放连接。这是第一个报文在网络结点延迟后到达服务器。服务器认为有新的连接请求，于是向客户端发送确认报文，建立连接(不采用三次握手)。但客户端忽略服务端的确认报文，也不发送数据，则服务端一直等待客户端发送数据，浪费资源。
②发送一个


### 3.操作系统




#### Base/编程算法
# ---------------------------------------------
### 1.排序算法

### 2.选择算法

### 剑指offer常问
字符串转换成整数
链表中倒数第K个结点 -- 栈
二维数组中的查找 -- 二分查找
替换空格
从尾到头打印链表 -- 栈实现
重建二叉树
*用两个栈实现队列
*斐波那契数列及变形题
二进制中1的个数 -- 布莱恩算法
在O(1)时间删除链表结点
调整数组顺序使奇数位于偶数前面 -- 双指针
反转链表 -- 保存父子结点栈实现
合并两个排序的链表
树的子结构
*二叉树的镜像
顺时针打印矩阵 -- 引入层数变量
*栈的压入、弹出序列
二叉搜索树的后序遍历序列
*二叉树中和为某一值的路径
数组中出现次数超过一半的数字
最小的k个数 -- 最大堆
连续子数组的最大和
第一个只出现一次的字符
两个链表的第一个公共结点 -- visited集合
链表中环的入口结点 -- Floyd判环
*跳台阶
变态跳台阶
矩形覆盖
从上往下打印二叉树 -- BFS
二叉搜索树的第K个结点

### 位操作
(1)a ^ b ^ b = a的应用
1.原地交换两个变量
通常做法：
a = a + b
b = a - b
a = a - b
异或做法：
a = a ^ b
b = a ^ b
a = a ^ b
位运算不会溢出，同时位运算速度也更快
2.O(n)复杂度找出成对数中的单独数
res = a1 ^ a2 ^ ... ^ a2 ^ a1 ^ alone
3.硬盘备份恢复
硬盘分为N部分，最后一部分n用于备份，是由其他部分异或得到的。当某一部分a数据受损之后，就可以用其他部分异或恢复：a^b^...^(n-1) = n -> a^a^b^...^(n-1)^n^n =n^n^a=a

