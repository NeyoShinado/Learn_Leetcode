# ---------------------------------------------
#### 笔试
## 不同类型题目
### 考点内容
题号前 + '*'代表未完成，+ '!'代表要回顾
#### 为大类    ### 为细分类别
# ---------------------------------------------




#### Base/编程原则
# ---------------------------------------------
### 快速做题的方式
1.弄清问题类型，根据场景选用合适算法和实现工具；
2.写好伪代码，搭起逻辑框架；
3.根据内容确定变量，端口以及边界条件；


### 变量定义
1.变量定义默认指定为语义对应的内容，这样代码的维护会方便很多；而不是为了表达式的整洁，如python 去背景下凑±1，这样会把边界问题复杂化；
2.同时需要遍历和更新操作的变量最好将遍历变量划分出来；如查找最大可行边长，一边用k在指定范围遍历，一边满足条件时更新l，比直接遍历l，更新时再回滚的情形要简洁；


### 边界条件
1.数据类型的取值范围
2.<,>,<=,>=将区间分割成的两部分；加上==,!=分割成了三部分
3.下标索引的三部分，id<0,0≤id≤size(),size()≤id
所有这些区间的左右边界就是要考虑的边界条件。


### 注释规范
#! /usr/bin/env python
# coding:utf-8
# @Time    : ${DATE} ${TIME}
# @Author  : Neyo
# @File    : ${NAME}.py
# @Software: ${PRODUCT_NAME}
"""The built-in HTTP Adapter for urllib3.   # 模块简介
# 使用场合
Provides a general-case interface for Requests sessions to contact HTTP and
HTTPS urls by implementing the Transport Adapter interface. This class will
usually be created by the :class:`Session ` class under the covers. 
# 输入参数
:param pool_connections: The number of urllib3 connection pools to cache.
:param pool_maxsize: The maximum number of connections to save in the pool.
:param pool_block: Whether the connection pool should block for connections.
# 用法
Usage::
>>> import requests
>>> s = requests.Session()
>>> a = requests.adapters.HTTPAdapter(max_retries=3)
>>> s.mount('http://', a)
"""


### python 配置递归上限⭐
python 默认递归深度小于1000，做DFS会比C吃亏，可通过sys.setrecursionlimit(10000000) 手动修改，如果仍然TLE 就需要剪枝优化了。


### python 缓存装饰器
functools模块的lru_cache装饰器记录函数调用的缓存结果，重复运行的函数直接返回缓存结果，不执行函数体。
使用方式：
from functools import lru_cache
@lru_cache(maxsize=2n, typed=False) 或@lru_cache(None)
def fun(...):
    ...
调用fun函数时就会自动查询缓存


### python 类内函数
同类方法函数间调用要添加self参数，使用时python自动为self赋值而不需自己赋值。
原因：创建一个类MyClass，实例化后得到MyObject对象。调用对象方法时MyObject.method(arg1, arg2)，python会自动将其转为Myclass.method(MyObject, arg1, arg2)


### python list
1.list作为中间变量或赋值时，要用.copy()深复制，不然任何的改动都会影响其他赋值的变量；
2.list循环中删除多个变量时，若删除下标有序，从大往小顺序删除能避免删除元素索引的错位；
3.*list的提取和删除；
4.注意[[]] * N通过浅复制创建多维数组，新建的各个[]是共享内存的。


### python set,dict⭐
1.创建空集合用set()，因为{}指空字典；
2.*类似JAVA，python的集合元素和字典键都不能使用可变对象（unhashable的对象），否则会报错；
3.set、dict的内建方法要熟悉使用。


### python 循环体
map(int, input().split()) 返回的是一个循环体，不能使用下标，必须转换为列表或使用for循环遍历访问元素


### python内置列表生成式
[expr for x in 循环体 if cond]--根据条件遍历循环体后放入列表中
注：if 放在for后面只用作x的筛选判断，不能加else；if 放在for前面为表达式，要加elsex确定值
>Samples:
1.list[range(1, 11)]
2.[x*x for x in range(1, 11) if x % 2==0]，筛选偶数的平方
3.[m+n for m in 'ABC' for n in 'XYZ']，两层循环
4.[k + '=' + v for k, v in d.items()]，多变量循环
5.[x for _ in range(5)]，循环但不使用变量则无需为其命名，使用'_'


### python字符串
*python join()在长字符串拼接时似乎会出错，原因未明，建议用+


### Java i++ 和++i
Java i++ 是使用再自增，自增时会创建一个临时变量；++i是先自增再使用，因为直接自增，在循环时会比i++快一点


#### Algorithm/算法
# ---------------------------------------------

### Dynamic Programming/动态规划⭐
思想：
动态规划的思路是空间换时间，其思路是从原始问题一个最小规模的问题开始，新问的最优解均是由比它规模还小的子问题的最优解转换得到的。通过状态转移方程记录下每一步求解的结果，直到问题解决。
递归则是直接求解问题，直接加缓存处理重复的子问题，亦称“记忆化递归”，记忆化是减少状态重复计算的重要步骤。
适用场景：
①问题有最优子结构：前面决策形成的状态中，最优方案一定存在于剩下决策状态中；
②无后效性：每个状态都是过去决策的总结，不受当前和未来的决策影响；
③子问题的重叠性：根据重叠问题去除冗余，将指数级的搜索改进为多项式时间状态遍历。


(221)maximal_square
在一个由0和1组成的矩阵内找到只包含1的最大正方形，并返回其面积。
>Summary:
1.最大正方形由其角的相邻两个正方形和对角相邻的一个正方形决定
2.!二进制数的连续与获得当前最大矩形边长，num&=num<<1算最大连续非零位(最大边长)


(300)longest_of_ascending_series
给定一无序整数数组，找出最长的上升子序列(LIS)，返回其长度。
>Summary:
1.动态规划中状态的设计非常重要，此题dp若设为以nums[i-1]结尾的最长LIS长度可以很容易地通过循环求解；但设为nums[0:i-1]中的最长LIS长度，会复杂许多，因为新区间最长LIS是否以nums[i]结尾以及哪个LIS以nums[i]结尾都无法从dp中提取出信息，这样划分不是最优划分；
2.*贪心+二分查找。贪心思想：要LIS尽可能长=>LIS增加得尽可能慢=>LIS末尾添加的数尽可能小。由此维护各长度i下LIS最小尾数的数组dp[i]，以及当前最长长度len。dp[i]一定是递增的，而新遍历到的元素nums[j]只有大于dp[len]才能刷新len以及dp[len]；否则nums[j]存在于dp中，并替换缩小第一个比它大的dp[i]，此步可以用二分查找，实现O(logN)的查找速度。
此方法解决了nums[0：i]中LIS长度和对应尾数未知的核心问题：即遍历到nums[i]时，能知道nums[i]更新的应该是哪一个LIS的最大长度，以及该最大长度能否刷新目前的最大值
3.!二分查找实现


## 股票问题
(121)max_profitⅠ
给定一数组，第i个元素代表股票第i天的价格。只允许一次买入和卖出，算出利润最大的交易(卖出在买入前)。
>Summary:
1.遍历过程中同步更新历史最低位，就能实时更新当天的最大利润。


(122)max_profitⅡ
同样给定股票数组，允许多次买卖，求最大利润。
>Summary:
1.*贪心算法，凡是上升段的收益都纳入总收益就是最大收益；


(123)*max_profitⅢ
给定股票数组，最多允许两次买卖，求最大利润。
>Summary:
1.


(309)max_profit
给定一整数数组，i元素代表第i天的股票价格。算出多次买入卖出后的最大利润。(卖出要在买入后，且两次买卖之间有一天的冻结期)
>Summary:
股票题目汇总:121, 122, 123, 188, 309, 714
1.!买入卖出可以统筹为负收益和正收益
2.按买入卖出区间划分的动态规划不可行，直接按当天状态分类讨论总获益更加直接


(322)coin_change
给定不同面额的硬币数组coins和一个总金额amount。计算凑成总金额所需的最少硬币数(硬币可以重复使用)，不能凑成则返回-1。
>Summary:
1.!构建回溯程序的空间设置：①(不使用栈，内存留存在函数空间)递归变量和结果保留在本层，变量分发给递归子程序，结果则与子程序的返回值一起整合。如编码字符串内外层拼接的过程；②若递归变量随着程序更新，回溯时需要进行上一层的逆操作，此时就需要栈等辅助记忆的数据结构(如路径和回溯上一层时要减去当前节点值)
2.!动态规划中，记忆化是减少状态重复计算的重要步骤。
3.*functools.lru_cache缓存函数结果，加快递归速度
4.√python循环式生成列表
5.!动态规划中不同子结构的构建方式，能避免递归的使用(从而避免爆栈)。如此题的自下向上构型，每层所需的状态都已生成好，避免了递归的嵌套结构。


## 区间动态规划
石堆合并

(312)max_coins
N个气球上标有不同的数字，存在数组nums中。戳破第i个气球后，将获得nums[left]*nums[i]*nums[right]个金币，求最终获得金币的最大值。
可以假设nums[-1]=nums[N]=1
注：戳爆气球i后，气球left和气球right就变为相邻气球。
0≤nums[i]≤100
>Summary:
首先，问题的复杂度是N!的，且每次戳的气球将改变数组的相邻关系，影响到下一次的结果，而每次戳气球的结果只跟当前气球排列有关，也就是说这是个//区间动态规划问题//！
1.+能实现数组的拼接
2.!Python缓存机制要求输入参数不可变且hashable
3.*区间动态规划
4.!Python运行速度(300ms)要显著慢于Java(6ms)，因为Java编译完脚本再运行，Python则是一边翻译一边运行




### Greedy/贪心算法
贪心算法跟动态规划很相似，不过动态规划的状态转移是由多个状态确定的；而贪心算法则是由一个状态(局部最优)确定的。




### Sort/排序 or TopK
平均达到O(NlogN)级别的排序算法，虽然快速排序的最坏情况位O(N^2)，但该情况很少出现，一般情况下都是快速排序速度最快




(215)find_Kth_largest⭐
在未排序的数组中找到第k个最大的元素(含重复元素)。
>Summary:
1.*三种排序算法的特点及源码实现




### Recursion/递归
递归调用涉及到大量函数的调用，临时变量及esp和寄存器的存取，需要栈帧的创建与释放，所以效率对比起动态规划是很低的。
(617)!merge_trees
将两个二叉树合并在一起，重合的节点相加，缺失的节点则拼接另一个节点上去。
>Summary:
1.！python类内函数和类外函数调用
2.*递归中只讨论最简要的情况，重复起来才会快(Version0中对左右子节点进行条件组合，会指数化增加程序规模)
3.！迭代实现递归，while+先进先出栈能实现递归的回溯过程
4.▲递归问题应该是自底向上、自内向外去理解问题的，所以我们往往看不清内部结构(因为内部未知)；递归问题的动态规划可以通过数学的归纳法证实，即1、2层的简单论证 + n、n+1层的论证。


(337)robⅢ
小偷在一个地区行窃，房子连成一棵二叉树。相邻房子被偷则会触发警报。问小偷能偷到的最大金额。
>Summary
1.递归函数返回数组能解决组合问题




### Divide and Conquer/分治
分治法是将复杂问题分解成多个相似的子问题，子问题也能重复划分成更多更小的子问题，直到最后的子问题可以直接求解，且原问题的解是子问题的合并。
可见分治算法能以*对数的速度*压缩问题规模，是很高效的算法。排序算法，快速傅里叶都是分治法的应用。
使用条件：①问题能分解为规模较小的相同问题；②子问题的解能合并出该问题的解
动态规划和分治的关系：
共同点：都要求问题又最优子结构--即问题的最优解包含了子问题的最优解
不同点：①分治要求子问题相互独立，即两个子问题之间不共享资源；②动态规划要求子问题有重叠，可通过记忆化避免重复计算。


## 1.二分搜索
1.应用场景：
①查询快的数据结构，如数组；
②数组有“二分”的性质，如大小、正负等；
2.两种类型：
①查找存在的目标元素：把区间分为小于等于大于三部分；
②排除一定不存在目标元素的区间：把区间分为剔除部分和保留部分，作为边界问题；▲
3.二分搜索的细节：
①迭代停止条件（边界相交？边界越界？）
查找类型的二分使用边界越界作为停止条件：while(left<=right?)，因边界是最后判别的，可能目标元素最后在边界上；
排除类型的二分使用边界相交作为停止条件：while(left<right)，退出循环时[left,right]只有一个元素left==right，该元素可能是目标元素，进一步的判断在循环退出后进行。
②中值选取
mid = left + (right - left) / 2，注：该中值总是偏向左侧的
③排除判定语句(if-else)
把"不是目标元素的条件"注释在判定语句中，接着考虑mid和mid的左右是否存在解
④边界收缩
mid分到左区间：[left,mid]与[mid+1,right]->right=mid或left=mid+1
mid分到右区间：[left,mid-1]与[mid,right]->right=mid-1或left=mid
注：mid分到右区间在最后剩下两个元素时，由于mid偏向左侧，有可能造成死循环▲
⑤结果更新
结果loc写在有把握出现答案的条件句中，另一句else就不用考虑更新了


(4)findMedianSortedArrays
给定两个正序数组，在O(log(m+n))时间内求出中位数
>Summary:
1.两数组同时使用二分法，排除对方不符合条件的一半，另需注意存在小数组下标越界的情况。


(300)longest_of_ascending_series
给定一无序整数数组，找出最长的上升子序列(LIS)，返回其长度。
3.二分查找实现细节


(240)search_matrix
搜索m×n矩阵中是否有目标值target。矩阵元素从左至右，从上往下都是升序排列。
1.排除法，从左下角/右上角开始逐行逐列排除


(287)find_duplicate⭐
给定一个n+1长整数数组nums，数字介于1到n之间，假设只有一个重复的整数，找出它。
要求原数组只读，使用O(n^2)时间和O(1)空间。
难点在于时空复杂度和数据只读的约束。
>Summary:
1.二分查找的特殊场景：令cnt[i]为nums中≤i的数目。两次重复的数为target，重复的target出现在左边时，[1,target-1]的数cnt[i]≤i,[target, n]中的数cnt[i]=i；出现在右边时，[1,target-1]的数cnt[i]=i,[target, n]中的数cnt[i]≥i；
对于多次重复的情况，被替换的数j<target，则[j, target-1]的cnt减一，其他不变；若j>target，则[target, j-1]的cnt均加一。可见，恒有cnt[target]-target>0，且该值被target分为非正和非负两个区间，用二分法找cnt-target>0的左边界即可确定target。
2.*Floyd判圈法
3.二进制位投票




### DFS/深度优先搜索
DFS隐式地实现了栈，一次遍历一条路径，其遍历具有回溯性，一般用于解决连通性问题。


(301)*remove_invalid_parentheses⭐⭐
删除最小数量的无效括号，使得字符串合法，且返回所有可能的结果。
注：输入可能有除"("")"外的字符。
>Summary:
*这题有好几个难点：①遍历复杂度为O(2^N)；②完全无法匹配时要返回""，有合法结果则不用返回""；③所有可能结果返回；④结果集中的去重▲
1.重复由两种情况产生：①连续括号的出现，如(()；②删除顺序的颠倒，如(()(()->()(()/(()()->()()。
▲可见可以通过约定删除括号的顺序：第二次删除括号必须在第一次删除括号之前。使用含循环+条件结构的递归实现，如解Version1示：进行下一层递归的判断条件i≥st+1 限定了删除的顺序是从前往后，选择“删除当前元素”为前提的遍历，进行纵向搜索。（当然也可以优先剔除后N个元素，但实现会复杂些）；而循环遍历+s[i]!=s[i+1]则相当于选择“不删除当前元素”为前提的遍历，进行横向搜索；
2.注意删除对象除了多余符号还有位置异常符号--如")("，这要求计数器L,R为正数才能有意义，按照先"("后")"的规则，先对l进行加一操作，匹配上的")"就对l进行减一操作；无"("匹配时，l＜0，就对r进行加一操作；
3.多结果返回应该设置全局变量，在遍历过程中添加子结果，不符则返回空；
4.用DFS是考虑删哪个括号，用BFS则是考虑删除多少个括号，一旦符合条件就直接返回结果，去重可以直接用集合实现，更加便利
5.*python 的filter(Fun,obj)函数
6.还可以使用左右扫描+限定顺序去重删除实现




### BFS/宽度优先搜索
BFS基于队列实现，一次遍历一层，用于解决最短路径问题。且避免了DFS易爆栈的问题，但需要的内存较大。
适用场景：层序遍历、最短路径问题BFS处理比DFS方便得多。若清楚结果离根比较近或需要广度搜索时，用BFS是较快的；但BFS不方便处理遍历过程中定位的问题（所以在非完全二叉树的场景下不太好用）

实现：BFS一般用队列一端推出当前点，另一端压入下一层新的子节点实现遍历，这种方法会有一个问题：混淆当前层和下一层的元素。这个问题可以在每层遍历前先统计当前层节点数N，然后在当前层的while遍历里使用N的for循环指定遍历当前层；另还可以用新键newlist的储存新节点。

相较于DFS的难点：BFS队列的维护没有DFS调用栈那么直观，下一层递归的子节点及更新值要合并在一起入列，同时还考虑查询是否成功、查询停止条件以及本层节点数等情况


(279)num_squares
给定正整数n，找到若干个完全平方数(1,4,9,...)使得他们的和为n。要求完全平方数的个数最少。
>Summary:
1.!N元树枚举+贪心优化
2.BFS




### Mazz/迷宫
*(130)被围绕的区域
给定一二维矩阵，含'X''O'，找到所有被'X'围绕的区域，并将其用'X'填充。
>Summary
1.从边界的点开始DFS探索，设计状态表visited。未探区域赋值0，探明'O'赋值1。搜索完后visited不是1的区域说明没有跟边界连通，改为'#'即可。


(LCP13)机关迷宫寻宝
>Summary:
1.*状态压缩DP




### 前缀和
>Summary:
前缀和很适合有序数据(无环链表，数组，树)的路径和和差分问题，而且速度往往很快
(437)path_sum




### 滑动窗口算法
>Summary:
滑动窗口算法基本框架就是更新窗口，右指针右移增大窗口，左指针右移缩小窗口。难点在于滑动阶段更新结果的时机。下面是一般滑动窗口算法框架：
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        // c 是将移入窗口的字符
        char c = s[right];
        // 右移窗口，扩大窗口
        right++;
        // 进行窗口内数据的一系列更新
        ...

        /*** debug 输出的位置 ***/
        printf("window: [%d, %d)\n", left, right);
        /********************/
        
        // 判断左侧窗口是否要收缩
        while (window needs shrink) {
            // d 是将移出窗口的字符
            char d = s[left];
            // 左移窗口，优化窗口
            left++;
            // 进行窗口内数据的一系列更新
            ...
        }
    }
}
应用问题：子字符串、子数组问题。
!要点：
①什么时候右移R 扩大窗口？
②扩大窗口时要作什么变动？
③什么时候增大L 缩小优化窗口？
④缩小窗口时要作什么变动？
⑤结果应该在缩小窗口时更新还是扩大窗口时？
系列训练：
76_minmum_window 最小覆盖子串
567_Permutation_String 排列子串
438_Find_all_anagrams 字母异位词
3_longest_substring
--如题76，最小覆盖窗口
①R++ 扩大窗口时，应该更新什么数据？(更新window计数哈希表)
②什么条件下停止扩大窗口，开始L++缩小窗口？(当窗口满足条件字符数cnt满足need时)
③L++ 缩小窗口时，应该更新什么数据？(减少window计数器)
④什么时候更新结果？(收缩窗口时更新结果，直至不满足条件)


(438)find_anagrams
给定一个字符串s和非空字符串p，找出s中所有p的字母异位词子串，返回其起始索引。




=======
### 背包问题
# ------------------背包九讲------------------ #
>Summary:
完全背包、多重背包都能转化为01背包问题解决。核心思想是“拆分物品”，将一定范围的物品取法划分为对应的2次幂系数基元构成的，件数为1的“新物品”组。
连续的k组成的基本元件数组：2^k能不重复元素地构成任何整数。这样能将原本O(N)的遍历复杂度优化为O(log(V/Ci))个基元的遍历复杂度。


#BagTest#
一、01背包问题▲
背景：有N种物体和容量V的背包。各物体体积Ci，价值Wi，件数只有一件。求放入包内物体的最大价值之和。
①思路：每个物体只有放和不放两种选择，当前状态只由之前状态决定，无后效性，可用动态规划解决。
②状态F[i,v]代表前i种物体花费体积v的最大价值；
③状态转移方程：F[i,v]=max{F[i-1, v], F[i-1, v-Ci]+Wi}
④伪代码：
# TC:O(NV), SC:O(NV)
F[0, 0...V] = 0     #初始化
for i = 1:
    for v = Ci:V    #新加入的第i种物品对F[i]从体积Ci起开始产生影响
        F[i,v]=max{F[i-1, v], F[i-1, v-Ci]+Wi}
⑤!空间优化：F[i,v]完全由体积<=v的F[i-1]确定，所以N*V维的状态矩阵可以优化至一行.
新的伪代码:
# TC:O(NV), SC:O(N)
F[0...V] = 0     #初始化
for i = 1:N
    for v = V:Ci    #!体积必须逆序遍历，以免把使用频率最高的小体积F[i-1]覆盖掉
    #!在不必装满场景下，体积遍历能进一步优化为V:max(V-Σ[i:N]Ci, Ci)
    # 因为Ci是物品i的体积起点，V-Σ[i:N]Ci则是最大价值开始“积累”的体积
        F[v]=max{F[v], F[v-Ci]+Wi}
⑥!初始化细节：上述要求是“在V容量下的最大价值”，若改为“恰好装满V容量的最大价值”，初始条件需要改变：F[0]=0, F[1:V]=-∞。这样只有恰好能装满的情况才会更新状态(初始化0则只会选最大值覆盖，即使没装满也会更新)



二、完全背包问题
背景：不同点在于N种物体有无限量件
①思路：每个物体的件数范围是0：int(V/Ci)，
状态转移方程变为：F[i,v] = max{F[i-1, v-kCi]+kWi|0≤kCi≤v}，所以总体复杂度变为O(NVΣ(V/Ci))；
②!直观的优化思路:易知件数无限制后，“价值密度”大的物体直接淘汰了小的物体，会尽可能多地装“价值密度”大的物体；因此Ci≤Cj且Wj≤Wi时，物品j直接剔除。该优化可以直接用计数排序以O(N+V)实现。
③!指数级拆分为01背包：2的连续次幂2^k能不重复地组合出任何的整数。所以，对于第i种物体，0:int(V/Ci)范围内的所有取法能被k≤log2(V/Ci)的二次幂以01背包（相当于2^k*Ci,2^k*Wi且只有一件的物体）的方式组合出来。这样把复杂度优化为O(NVlog[V/Ci])；
③*伪代码：
# TC: O(NV)
F[0...V] = 0     #初始化
for i = 1:N
    for v = Ci:V    
    #▲01背包中采用逆序为了保证i物品最多选一次，必须从没有选i的状态F[i-1,v-Ci]中递推来
    # 而完全背包中可能从选了i的状态F[i,v-Ci]中递推，必须使用v顺序遍历才能实现重复选取同一物品的效果
        F[v] = max{F[v], F[v-Ci]+Wi}


三、多重背包问题⭐
背景：不同点在于第i种物品最多Mi件可用，仅相当于改变了件数范围
①思路：和完全背包类似，状态转移方程F[i, v] = max{F[i-1, v-k*Ci]+k*Wi|0≤k≤Mi}，原始复杂度为O(NVΣMi)
*注：多重背包之于完全背包最重要的区别在于“有限-无限”件数。因为件数无限制，完全背包能在任意状态加上物品，实现O(NV)的复杂度；而由于添加物件的位置不确定，多重背包只能通过N,V,K三重循环遍历或者使用转换为指数优化规模的01背包问题。
同时，多重背包使用三重循环遍历时，体积v也要逆序遍历，这样才能不重复前期关于k的选择策略。
②指数级拆分为01背包：0:Mi可拆分为1,2,2^2,...2^(k-1),Mi-2^k+1(Mi-2^k+1>0)基元的01组合。问题复杂度转为O(NVΣlogMi)
③处理一件多重背包物体的伪代码：
def multiplePack(F,C,W,M):
    if CM≥V:
        completePack(F,C,W)
    k = 1
    while k<M:
        zeroOnePack(F,kC,kW)
        M = M-k
        k = 2*k
    zeroOnePack(F,MC,MW)    # 最后余数还要再进行一次01背包规划
④多重背包还能使用单调序列将复杂度优化为O(NV)级别！比二进制优化的O(NVlogM)还要快
https://www.cnblogs.com/-guz/p/9866118.html


四、混合背包问题
背景：不同类型的物品混合在一起
①伪代码：
for i = 1:N:
    if 物品i属于01背包：
        zeroOnePack(F, Ci, Wi)
    else if 物品i属于完全背包：
        completePack(F, Ci, Wi)
    else if 物品i属于多重背包：
        multiplePack(F, Ci, Wi, Mi)


五、二维费用的背包问题
背景：对于每个物品有两种费用v,u，两种费用背包都有对应的最大容量值。
①状态转移方程：F[i,v,u] = max{F[i-1,v,u], F[i-1,v-Ci,u-Di]+Wi}
②隐含的二维费用：部分问题的二维费用没有明说，如最多取U件物品，相当于每件物品多了一个“件数”费用。


六、分组背包问题
问题：N种物品被分为K类，同类的物品相互冲突，最多选一件。
①思路：策略变为从改组选一件，还是不选改组。直接和状态相关的变为组而非物品，状态F[k,v]。转移方程为F[k,v] = max{F[k-1, v], F[k-1, v-Ci]+Wi|item i ∈group k}
②伪代码：
#*同组物品互斥，所以要最后一轮循环中比较取舍，不能放在v遍历之前(否则会到同组物品)
for k = 1:K:
    for v = V:0:
        for all item in group k:
            F[v] = max{F[v], F[v-Ci]+Wi}


七、有依赖背包问题
问题：物体间存在“依赖”关系，被依赖的称为主件，依赖其他物体的称为附件。假设只有简单的依赖关系：附件不会被其他物体依赖，只会依赖一个主体。
①思路：一个主件附件套装能有2^n+1种选法：一个不选、选主件、选第一个附件...。鉴于这些选择策略是互斥的(一次最选其中最佳的一种)。主件和附件集合能看作一个物品组。DFS策略。
然后是对策略数量的优化，先对附件集合进行一次01背包，得到不同费用(0,...,V-Ck)对应的最大价值Fk[0,...,V-Ck]。这个主附件集合相当于V-Ck+1个物品的物品组。这样就去除掉了指数策略中的许多冗余。


八、泛化物品
定义：泛化的物品类似于一个函数，其价值随着费用而变W(v)。01物品、完全物品、多重物品相当于定义域不同的泛化物品，物品组、主附件集合也可以看作一个泛化物品。
①两个泛化物品h,l的状态转移式：F(v) = max{h(k) + l(v-k)|0≤k≤v}，复杂度为O(V^2)


九、背包问题形式的转换
注：当需要求方案或数量等与策略过程相关的对象时，转移状态应该使用二维数组以便回溯跟踪。
①输出最优方案：可以在遍历过程中增加记录数组G[i,v]，G[i,v]=0说明F[i,v]没有选物品i，否则选了；也可以根据最大值逆向回溯出选取方案；
②*输出字典序最小的最优方案：
③求背包装满的方案总数：初始条件设为F[0,0]=1，状态转移方程改为F[i,v]=sum{F[i-1,v], F[i,v-Ci]}即可；
④最优方案总数：G[i,v]代表子问题的最优方案总数
G[0,0] ← 1
for i ← 1 to N
for v ← 0 to V
F[i,v] ← max{F[i − 1,v],F[i − 1,v − C i ] + W i }
G[i,v] ← 0
if F[i,v] = F[i − 1,v]
G[i,v] ← G[i,v] + G[i − 1][v]
if F[i,v] = F[i − 1,v − C i ] + W i
G[i,v] ← G[i,v] + G[i − 1][v − C i ]
⑤次优解、第K优解：每个状态替换为长度K的有序队列，F[i,v]的队列在状态转移中由F[i-1,v]和F[i-1,v-Ci]+Wi两个有序队列合并的到。总的复杂度为O(NVK)
注意区分策略不同但价值相同的方案作为同一解还是不同解；前者的维护队列结果不重复。


# ------------------背包九讲------------------ #


(416)can_partition⭐
给定一只含正整数的非空数组，是否可以将其分割成两个子集，使得子集的元素和相等。
>Summary:
1.!动态规划的步骤(状态定义；状态转移方程；初始化；输出；状态压缩)
2.背包算法
3.*拓展：元素范围--①含0，思路差别不大；②含实数，计算和一半时会遇到精度问题；③含负数，需要回溯搜索方法。




### Floyd算法查询最短路径




#### Type/类型
# ---------------------------------------------
### 数组
(1)series_sum
给出一个正整数N和长度L，找出一段长度大于等于L的连续非负整数，和为N。找出长度最小的那个。
输入描述:
输入数据包括一行： 两个正整数N(1 ≤ N ≤ 1000000000),L(2 ≤ L ≤ 100)
输出描述:
从小到大输出这段连续非负整数，以空格分隔，行末无空格。如果没有这样的序列或者找出的序列长度大于100，则输出No。
>Summary:
1.√map(Fun, Iterable_object) , 对可迭代对象重复运算；返回迭代器(只可往前迭代，迭代完成时引起StopIteration 异常。)  
2.√python遍历习惯从0开始  
3.注意python数值运算过程中自动对数据类型的扩展变换  
4.^ 是按位异或运算符，** 是幂运算符




### String/字符串
(3)length_of_longest_substring
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
>Summary:
1.滑动窗口动态规划
2.Python 的数组矩阵操作、Numpy--array、Pandas--Series,df
3.Python 字符串函数


(11)longest_palindrome⭐
找出字符串s的最长回文字串。
>Summary:
1.！注意指针加偏移值的负值，边界以及尾部加一情况  #"ccb"
2.情况枚举的相互独立，相互穷尽  #"sooos"
3.range() 函数的某位设定（正负步长）
4.*马拉车算法


(20)valid_bracket
给出只含'(', ')', '{', '}', '[', ']'的字符串，要求左右括号按顺序闭合，验证字符串是否有效
>Summary:
1.字符串的删除
2.递归和栈


(394)decode_string⭐
给定一编码字符串，返回解码后的字符串。
编码规则为：k[encoded_string]，数字字符k表示encoded_string重复的次数。默认括号是符合格式的。
>Summary:
1.!ASCII字符转码数字
2.*缓存变量的初始化、更新以及删除时刻
3.!算术进位解决多位数字字符的重复遍历问题
4.s.isalpha(),isdigit(),isalnum()
5.字符串split()转列表，列表.join()转字符串
6.*递归函数通过返回索引值解决递归索引的跳变问题
7.*动态规划流程


(647)!count_substring
给定一字符串s，计算其中有多少个回文子串。不同开始、结束位置被视为不同子串。
>Summary:
1.中心扩展算法√
2.*马拉车算法




(21)merge_two_list
将两个升序链表合并为一个升序链表，通过拼接给定结点组成。


(22)generate_parenthese
给定n，要求生成所有可能且有效的n对括号组合。


(23)merge_K_Lists
合并K个排序链表，返回新的排序链表。


(31)next_permutation


(32)longestvalidparenthese
给定一只包含'('和')'的字符串，找出最长有效括号子串长度
>Summary:
1.通过条件赋值语句(a = b if .. else c)在遍历过程中解决初始化的问题
2.运算符的优先级
3.！通过拒止栈解决连续字符串长度的问题
4.字符串翻转s[::-1]


(33)Search_flip_point_of_sorted_str
一升序数组在点某发生旋转，(如[0,1,4,5]变为[4,5,0,1])，假设数组无重复元素。
搜索发生旋转的索引，不存在则返回-1，要求时间复杂度O(log n)级别。


(34)Search_range
给定一升序整数数组nums，和目标值target。找出目标值在数组中的开始位置和结束位置。不存在则返回[-1,-1]。要求O(log n)级别。


(39)combination_sum
给定一无重复正整数元素数组和一目标数，找出数组中和为目标值的所有组合，数组的数字可以重复选取。


(42)trap
接雨水，给定n个非负整数表示宽度为1的柱形图，柱形紧靠，计算下雨后能接多少雨水。


(46)permute
给定一组无重复数字，返回所有可能的全排列。


(48)matrix_spin
给定一n×n二位矩阵，原地顺时针旋转90°返回，要求原地旋转，不另建矩阵。


(49)group_anagrams
给定一个字符串数组，将所有字母异位词(字母相同，排列不同)组合为一组返回。
例：
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]


(53)max_sub_array
给定一整数数组nums，找到一最大和的连续子数组(最少一个元素)，返回其最大和。


(55)can_jump
给定一非负整数数组，从第一位开始，元素的值代表该位置可以跳跃的最大长度，判断是否能到达最后一个位置。


(56)merge
给出一个区间集合，合并所有重叠的区间。
如：[[1,4],[4,5]]
返回：[[1,5]]


(62)unique_path
一机器人位于m×n矩阵的左上角，每次只能向下或向右移动一步。机器人有多少种路径到达右下角。


(64)min_path_sum
给定一非负整数的m×n矩阵，每次只能向下或向右移动一步。找出一条从左上角到右下角的路径，使得路径上的数字和最小。


(70)climb_stairs
给定一n阶楼梯，每次可爬1或2个台阶，有多少种不同方法爬到楼顶。


(72)min_distance
给定两个单词word1和word2，算出word1转换成word2的最少操作数。
允许进行三种操作：①插入一个字符；②删除一个字符；③替换一个字符


(75)sortcolors
给定一包含0，1，2的n元数组，原地对他们排序使得相同元素相邻且以0，1，2的顺序排序。


(76)min_window
给定字符串s，和t，在S中找出包含t所有(有可能重复)字符的最小字串。
没有则返回""；如果存在，则是唯一的。


(78)subset
给定一组不含重复元素的整数数组nums，返回该数组所有可能的子集。
例：nums=[1,2]
返回：[[1],[1,2],[2],[]]


(79)exist
给定一个二维网格和一个单词，通过相邻单元格按顺序查找，判断该字母是否存在于网格内。(同一单元格内的字母不重复使用)


(84)largers_rectangle_area
给定n个非负整数，表示并排的柱形高度，柱子宽度为1，求该柱形图中最大的矩形面积。


(85)maximal_rectangle
给定一个仅包含0、1的二维矩阵，找出只包含1的最大矩形并返回其面积。


(94)inorder_traversal
给定一个二叉树，返回他的中序遍历。


(96)num_trees
给定一整数n，求以1...n为节点组成的二叉搜索树有多少种？


(98)is_valid_BST
给定一个二叉树，判断其是否是一个有效的二叉搜索树
二叉搜索树的特征：①节点的左子树只包含小于当前节点的数；②节点的右子树只包含大于当前节点的数；③所有子树都是二叉搜索树


(101)issummetric_tree
给定一二叉树，检查它是否镜像对称。如[1,2,3,4,4,3]是对称的。


(102)level_order
给定一个二叉树，返回按层遍历(逐层遍历，从左往右)的所有节点。


(104)max_Depth
给定一二叉树，找出其最大深度(离根节点最远的叶节点距离)。


(105)build_tree
根据一棵树的前序遍历和中序遍历构造二叉树


(114)flatten
将二叉树按中序原地展开为单链表


(124)max_path_sum
给定一非空二叉树，返回其最大路径和。能从任意节点出发，到达任意点的序列。


(128)longest_consecutive
给定一未排序整数数组，找出最长连续序列的长度。要求TC为O(N)
#* 注意区分连续序列和连续数组


(136)single_number
给定一非空数组，有某个只出现一次的元素，其余每个元素都出现两次。找出那个元素，TC为O(N)且不使用额外的空间。


(139)word_break
给定一非空字符串s和包含非空无重复单词列表的字典wordDict，判定s是否可以拆分为一个或多个在字典出现的单词。(字典的单词可以重复使用)


(141)has_cycle
给定一链表，判断链表是否有环。有则返回该环开始的链表位置，否则返回-1。
进阶：要求SC为Ｏ(1)


(142)detect_cycle
给定一个链表，返回链表开始入环的第一个节点，无环则返回Null。不允许改定链表。
进阶：不使用额外空间。


(146)LRU_Cache
构建一个LRU缓存机制，支持数据的get(key)和put(key, value)功能。
get(key)时，关键字已存在则返回值，否则返回-1.
put(key, value)时，如果关键字已存在，则更改值；不存在则插入新值。缓存达到上限时，删除最久未使用的数据再插入新值。
进阶：TC为O(1)


(148)sort_list
在O(NlogN)TC和O(1)SC下对链表进行排序。


(152)max_product
给定一整数数组nums，找出数组中乘积最大的连续子数组(至少含一个数字)，返回该乘积。


(155)min_stack
设计一个支持push,pop,top,getMin操作的栈。要求检索最小元素TC为O(1)
push(x) -- 入栈
pop() -- 删除栈顶元素
top() -- 获取栈顶元素
getMin() -- 检索栈中最小元素


(160)get_intersection_node
查找两链表的相交节点(只有一个)


(169)majority_element
给定一个大小为n的非空数组，找到其中的多数元素(出现次数大于n/2的元素)


(200)!Islands_nums
给定一由"1"陆地和"0"水组成的二维网络(默认边界是水)，在水平垂直方向上相邻的陆地算为同一个岛。计算网格中岛屿的数量。


(206)reverse_list
翻转一个单链表


(207)!can_finish_lesson
某学期必须修n节课，其中有些课需要先修其他的课(正确的依赖关系形成单向无环图)。给定n和依赖课程的列表，确定能否完成所有的课程。


(226)invertTree
镜像翻转一棵二叉树


(234)is_palindrome_listnode
判断一个链表是否为回文链表


(238)product_except_self
给定一长度n>1的数组nums，返回一数组output。output[i]等于nums中除了nums[i]外其余元素的乘积。要求不能用除法。


(283)move_zeros
给定一个数组nums，将所有的0移到数组的末尾，同时保持非零元素的相对顺序。必须在原数组上操作。




### Sequence/序列
>Summary:


(10)!median_of_sorted_seqs
找出两个正序数列的中位数，要求时间复杂度不大于O(log(m+n))
>Summary:
1.二分法(k分法)实现对数级别的复杂度
2.设计算法关于空间复杂度的考量
3.√归并排序算法：通过等份划分再逐层排序，使得排序算法的时间复杂度从暴力枚举的O(N^2)降至O(NlogN)，空间复杂度为O(N);Python与Java的排序算法也是用基于归并排序的Timsort。
归并排序的核心，是每次排序归并记录了上一次排序的大小顺序(二叉树结构)，所以每次归并摸清的集合元素以两倍的规模上升。枚举排序由于没有保留每次排序的记录，所以重复的计算量很大。
4.python测试
5.程序的边界条件考虑
6.编程的逻辑结构
7.尾递归


(15)max_area
水桶容积：输入一正整数组，长为n≥2，代表坐标内各点上的垂线。找出其中两条线与x轴构成容器，使得容积最大。
输出容积。
注：容器不能倾斜
>summary:
1.双指针法
2.python 的不可变对象lazy赋值，可变对象赋值


(16)threesum
三数之和：给出一个n整数数组nums，判断nums中是否存在三元素，使得a+b+c=0?找出所有满足条件且不重复的三元组。
输出：数组集合
>summary:
1.数组排序
2.数列取集合
3.！跳过嵌套循环的外层循环
4.√数组可以通过排序等方式实现组合查找
5.！定义变量名与内建函数重名会重载该关键字，覆盖原来的对象


(406)reconstruct_queue
假设打乱顺序的人站在一个队列里，每人由(h,k)表示。h表示身高，k表示排在前面且身高≥h的人数。重建出原队列。
>Summary:
1.*双值排序问题
2.!python sort+lambda匿名函数实现双键值排序
3.本题先按身高排高的人(矮的人对高的人没影响)，再按k排等身高的顺序。


(560)subarray_sum
给定一整数数组和整数k，找到该数组中和为k的连续子数组个数。
>Summary:
1.子数组之和可表示为前和减去后和
2.注意起始条件和k为0的特例


(581)find_unsorted_subarray
给定一整数数组，找出一连续子数组，如果对其升序排序，整个数组都会变成升序排序。返回其最短长度。
>Summary:
1.*不用厘清所有大小关系，只需要知道无序数组中最大最小值的正确位置
2.*用栈能实现极大/小值和最大/小值的快速比较




### Permutation/排列组合
(17)lettercombinations
给出一个2-9的字符串，返回所有它能表示的字母组合。数字到字母的映射与电话九宫格按键相同。
如：输入-“23”，输出-["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]


(18)remove_Nth_from_end
删除链表的倒数第N个节点：给出一链表，删除链表的第n个节点并返回其头节点。
如：
输入 - 1>>2>>3>>4>>5, n=2
输出 - 1>>2>>3>>5


(301)*remove_invalid_parentheses⭐⭐
删除最小数量的无效括号，使得字符串合法，且返回所有可能的结果。
注：输入可能有除"("")"外的字符。


(448)find_disappeared_numbers
给定一范围[1,n](n为数组大小)的整数数组，数组中的元素只出现一次或两次，找出[1,n]中没出现的数字。
>Summary:
1.对于限定范围的输入，可以通过+N或取负等哈希函数引入标志；
2![1,N]的元素范围可在对应索引上标记数组元素，起到原地处理的作用。


(494)find_target_sum_ways⭐
给定一非负整数数组an和目标数S。假定可以在任一整数上加上+或-。返回使得和为S的所有添加方法数。
>Summary:
1.递归能实现指数级别的遍历
2.深度优先搜索(DFS)
3!背包算法
*背景：有N件物品和容量为V的背包，第i件物品消耗容量Ci，价值为Wi。
背包问题可分成3种不同子问题：①0-1背包问题；②完全背包问题；③多重背包问题。其他都是这3种的变形和组合。
①01背包 -- 装哪些物品能使背包的总价值最大；
②完全背包 -- 有N种物品，可重复取，怎样装总价值最大；
③多重背包 -- 有N种物品，第i种物品最多Mi件可用。怎样装总价值最大；
三类问题都有共同的容量限制和最大价值目的，区别在于物品数量的限制。最终都能转化为*01背包*




#### Data Structure/数据结构
# ---------------------------------------------
### Bit/位运算
>Summary:
1.基础位运算 -- 对2取余:x & 1   整除2:x>>1    奇数:x|1
2.布莱恩算法算非零位数目：x&(x-1)
3.计算连续非零位的最大长度：num &= num << 1


(191)hammingWeight
计算整数二进制中位“1”的个数--汉明重量。


(338)count_bits
给定一个非负整数num。对于0≤i≤num的所有数字i，计算其二进制数中的1出现次数，返回一个N+1长的计数数组。
>Summary:
1.汉明距离计算中关于最高有效位、最低有效位、和最低设置位的动态规划。


(461)hamming_distance
给出两个整数x和y，计算其二进制数的汉明距离。
>Summary:
1.!布莱恩.尼克根算法通过nums & nums-1 实现直接count 1位数



### Stack/栈
(739)daily_temperatures
给定一气温列表，生成等长的列表。对应位置表示气温超过当日温度所需要的天数，若不存在则输入0。
>Summary:
1.无前效性(及只受最近值影响)的问题可用单调栈解决(先进后出)√
2.* python range() 的-1
3.* 先进先出栈可以以相反顺序(对于栈)解决问题


(2)Sum_of_two_num(Linked-list)
给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字0之外，这两个数都不会以0开头。
>Summary:
1.if-else 条件赋值语句的多种写法：
if a>b:
    c=a
else:
    c=b
------
c = a if a>b else b
------
c = [a,b][a>b]
------
c=(a>b and [a] or [b])[0]
2.√链表定义注意预保留首结点，否则更新指针容易丢失表头
3.def foobar(a:int, b:"it's b", c: str=5) -> tuple: 函数注解语法(Function Annotations)
获取注解有两种方法：
①foobar.__annotations__; ②import inspect, inspect.signature(foobar)
另，Python 解释器不会基于函数注解自动进行类型检查，类型检查需要自己实现。




### BinaryTree/二叉树
# ------------------Summary--------------------
##1*

# ---------------------------------------------
## 二叉树的遍历思想
二叉树遍历分为深度优先遍历--先访问第一子节点，再访问父节点，最后访问第二个节点(前序、中序、后续)和广度遍历--先访问第一节点，再访问第二节点，最后访问父节点(层次遍历)；前中后续是指根节点放置于左右节点的位置分成的三种情况。
前序遍历：根节点—>左子树—>右子树
中序遍历：左子树—>根节点—>右子树
后续遍历：左子树—>右子树—>根节点
层次遍历：逐层从左往右


(236)lowest_common_ancestor⭐
给定一二叉树，找到该树中两个指定节点的最近公共祖先(一个节点也能是自己的祖先)。
>Summary:
1.DFS 遍历返回LCA；
2.*字典记录父节点，集合记录一个节点的已访问父节点，再访问另一节点的父节点，第一个再现的就是LCA；
3.*类似JAVA，python的集合元素和字典键都不能使用可变对象（unhashable的对象），否则会报错；
4.二叉树汇总中的含剪枝遍历算法比完全遍历会稍微快一些。


(297)！bin_tree_serialization
序列化是将对象转为可存储的比特位。设置一个算法序列化和反序列化二叉树。序列化输出的是字符串。不能使用全局变量。
>Summary:
注：怎么能只用一个字符串（一种遍历顺序）重建二叉树呢？
答：添加注释符号，如None, None标志叶结点
1.DFS实现
2.！序列缓存当前层非空节点，实现BFS




(437)path_sum
给定一个二叉树，找出路径和等于给定数值的路径总数。(不需要从根节点开始，但方向必须向下)
>Summary:
1.递归考虑两个方面：①最简单的子问题求解；②其他问题不考虑内在细节，只考虑整体逻辑
2.!python类内函数的调用
3.!前缀和很适合处理有序数据的路径和或差分问题，且速度往往很快(因为用上了哈希表)。此题只需要遍历一次
4.!注意有回溯步骤时，计数表要减去当前前缀和，因为当前前缀和是不属于前缀节点的


(538)convert_BST
给定一二叉搜索树，将其转换为累加树，使得节点值是原所有大于等于该节点值的和。
>Summary:
1!二叉树的递归时一次只处理本节点，子节点放进下层递归进行，这样只用讨论节点存在与否的问题，避免的子节点的繁琐讨论；同时避免了这层子节点和下一层根节点重复处理的问题。
2!反序中序遍历，二叉树的各种遍历
3!递归顺序只能由下层至上层，此题累加从子树的右下至左下进行，一般递归方法下左子树的值没能加上外层的较大值的和，需要引用全局变量记录累加值
4!先进后出栈实现中序反序遍历
5!Morris 遍历实现SC:O(1)


(543)diameter_of_binary_tree
给定一二叉树，计算其最大直径长度。即任意两节点路径长度的最大值。
>Summary:
1.二叉树最大路径长度为某一节点子树的最大左右路径长之和
2！递归算法两个基本要点：①一次递归带来的改变是什么②递归的起始条件如何


## 前缀树
前缀树常用于检索字符串集中的键，有多种应用：自动补全；拼写检查；IP路由(最长前缀匹配)；九宫格打字预测；单词游戏。
1.平衡树和哈希表也能搜索单词，但前缀树的优势如下：
①找到同一前缀的全部键值；
②按词典序枚举字符串数据集；
③占用空间少且不会出现冲突；键长m的搜索只要O(m)，在平衡树中需要O(mlogm)
2.特点：
①每个子结点最多R(字母数量)个父节点；
②值为布尔字段，True表示键的结尾，False表示键前缀


(208)Trie
实现一个前缀树，包含insert,search,startsWith三个操作
>Summary:


(211)WordDictionary
设计一个可以搜索文字或正则表达式字符串的数据结构。"."可以表示任何字母。


(212)*findWords
给定一二维网络和单词列表，找出所有同时在两者中出现的单词。二维网络中单词字母按顺序在相邻单元格内出现，同一单元格字母不能复用。





### heap/堆
堆非常适合处理海量数据的topK，分位数。相对应的，优先队列适合元素优先级排序。他们的排序复杂度为O(NlogK)，在总体规模N大而维护规模K小时优势明显。
其本质都是完全二叉树。
结构：常用数组实现的完全二叉树（深度h，除了h层外，其他各层节点数都达到最大个数，且第h层的节点都连续集中在最左边）

属性：堆分为大根堆/小根堆，父节点的值大于/小于子节点的值。从上往下每一条支路都是排序的，但堆元素不一定按下标排序。

能用数组实现，根节点索引在0，第i个节点的左右子节点分别为2i+1,2i+2；左右节点的父节点都是(i-1)//2。根节点在1，则第i个节点的左右子节点分别为2i和2i+1；父节点都是i//2。

优点：插入、删除快，对最大/小数据项的存取很快

缺点：对其他数据项的存取很慢

基本操作：

①上浮shift_up:当前节点与父节点比，比父节点小(小根堆的话)就交换当前节点和父节点下标，直到浮不动；O(logN)

②下沉shift_down:当前节点与较小子节点(小跟堆)交换下标，直到沉不动；O(logN)

③插入insert:将元素插入到heap末尾，再进行上浮更新树以恢复次序；O(logN)

④弹出pop:将最后一个元素与根节点交换，然后从根节点开始下沉；O(logN)

⑤取顶top:直接返回根节点；

⑥堆排序heap_sort:创建一个新数组，重复将堆顶元素弹出则完成排序（注，堆排序是不稳定排序，因为同样键值的元素在不同子树的位置可能有起伏）；O(N)

⑦建堆heapify:两种途径 -- Heapinsert:在末尾insert节点，然后shiftup；Heapify:在最后一个非叶子节点到根节点一直进行堆化操作，类似一元素shiftdown到底；O(N)

复杂度：以Heapify为例，非子叶节点总数N/2；高度h的节点总数\frac{N}{2^{h+1}}个，最多下沉h次。所以总的复杂度为\lim_{N\rightarrow ∞}\frac{N}{2}\sum_{h=0}^{log_2N}\frac{N}{2^{h+1}}h\approx N

⑧删除delete:删除元素的位置替换上末位元素后视情况shiftdown或shiftup；O(logN)

应用场景：①优先队列；②海量数据找寻少量topK，复杂度为O(NlogK)，十分可观

堆的其他练习：
1.数据流的中位数--https://leetcode-cn.com/problems/find-median-from-data-stream/
2.数组中的第K个最大元素--https://leetcode-cn.com/problems/kth-largest-element-in-an-array/
3.最小的k个数--https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/

(347)top_K_frequent
给定一个非空整数数组，返回出现频率前k高的元素数组。
>Summary:
1.最小堆查找TopmaxK，最大堆查找TopminK
2.桶排序，先用哈希表统计频数，再把频数作为下标，将键值塞进对应的列表中，类似一个个桶
3.root索引为1的堆父子节点索引更方便，il=2*ip ir=2*ip+1 ichild=ip//2；可通过位操作实现:il=ip<<1 ir=ip<<1|1 ichild=ip>>1
4.堆的shift_up,shift_down以及*heapsort实现
5.上浮下沉操作中创建新变量(2行)比循环替换更快(4行)
6.!python list.append添加整个对象，.extend将对象看作序列合并在后面
7.!python dict.get(key, default=None)，第二个参数是键值不存在时返回的值，常设0




### Queue/队列
队列是先进先出线性表，一般用链表或数组实现。有入队和出队操作，只允许队首出队，队尾入队，类似于排队行为。


(239)!max_sliding_window
给定一个数组nums，大小为k的滑动窗口从左至右移动，返回每次移动后窗口中的最大值。
难点在于随着窗口移动当前最大值与其相对窗口的位置关系不好维护
>Summary:
1.*使用双向队列维护最大值及其后方的候选“最大值”，而为了知道最大值是否存在于窗口内，选择将下标而非数值推入队列。移动窗口时，队首与窗口前端下标对比以确保最大值仍在窗口内，队尾中小于新值的元素会被移除，以确保候选的“最大值”足够新，足够大。上述的双向操作能由双向队列很好的完成，所有元素都有入列出列两次操作，复杂度为O(2N)
2.*动态规划思路：将数组分为多个K单元的子组，产生左向和右向的最大值数组，窗口[i,j]最多跨越两个子组，可以由max(left[j],right[i])将问题分解为左右部最大值。生成三个数组的复杂度为O(3N)


(621)*least_interval
设置一个任务调度器。输入表示任务列表的字符串s以及同种任务(相同字符)间的冷却时间n。CPU能处理任务或待命，问完成所有任务的最短时间。
>Summary:
1.!贪心算法




### Graph/图
# ------------------Summary--------------------
##0## 各类图的构造方法
1.无向图
2.有向图
3.有环图
4.无环图
##1## 最短路径问题
1.Dijkstra算法
>Summary:
1.主要处理单源正权最短路径--O(N^2)
2.算法思想为贪心算法

2.Floyd/插点算法
>Summary:
1.主要处理多源最短路径，适用于无负值环形的图
2.!核心思想是动态规划，每一对点的最短距离为自身或插入一个点的松弛距离。
3.TC: O(N^3), SC: O(N^2)
4.流程：先按图初始化距离矩阵dp，没有直接相连的边设一很大值∞，自身距离设0；
试探N个点，依次将其插入dp[ij]中，更新当前最短距离；
插点试探的状态转移方程为：dp[ij]=min(dp[ij],dp[ik]+dp[kj])，即ij的最短距离应该和ik最短距离与kj最短距离之和比较；
4.试探完N个点之后，dp为各点间的最短距离。


3.SPFA算法


##2## 环形存在判断


##3## 环形入口判断
1.Floyd判圈法
TC: O(N), SC: O(1)
在起点设置快慢指针，慢指针每次走一步，快指针每次走两步，有环情况下两指针肯定相遇。相遇后再将slow放到起点，此时快慢指针每次都走一步，重新开始前进，再次相遇的点就是环的入口。
解析：
设环长L，起点到环入口的步数为a，入口到首次相遇位置步数为
b，相遇位置到入口步数为c。
第一次步行时有2(a+b)=a+b+kL(a>0时，K≥1)，即a=kL-b=(k-1)L+c。
可见，第二次步行时，慢指针走了a步，快指针在B点走了k-1圈+c步，回到了环的入口。

# ---------------------------------------------
(287)find_duplicate
给定一个n+1长整数数组nums，数字介于1到n之间，假设只有一个重复的整数，找出它。
要求原数组只读，使用O(n^2)时间和O(1)空间。
>Summary:
1.二分查找
2.*Floyd判圈法


(399)calc_equation⭐
方程式A/B=K,AB为字符串表示的变量，K为浮点数字。根据给定的已知方程和结果求解问题方程的解值。
描述示例：
给定 a / b = 2.0, b / c = 3.0
问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 
返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]
输入示例：
equations(方程式) = [ ["a", "b"], ["b", "c"] ],
values(方程式结果) = [2.0, 3.0],
queries(问题方程式) = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]
>Summary:
*多源最短路径问题
1.*python zip构建新循环体
2.!嵌套字典构建双向图
3.!由于没有树的层次结构，图的遍历需要一个表记录已访问的节点，避免陷入环形循环
4.BFS
5.!Floyd算法
6.*并查集数据结构




### Disjoint set/并查集
并查集主要用于解决元素的分组问题，管理一系列不相交集合。支持两种操作：①合并(Union)--合并两个不相交集合；②查询(Find)--查询两元素是否在同一集合。
背景问题：亲戚问题
相关问题：路径压缩、rank优化
(399)calc_equation




#### Database/数据库
# ---------------------------------------------




####　Multi-progress-多线程
# ---------------------------------------------
