# ---------------------------------------------
## 不同类型题目
### 考点内容
题号前 + '*'代表未完成，+ '!'代表要回顾
# ---------------------------------------------


## Algorithm
# ---------------------------------------------

### Recursion/递归
!(617)merge_trees
将两个二叉树合并在一起，重合的节点相加，缺失的节点则拼接另一个节点上去。
>Summary:
1.！python类内函数和类外函数调用
2.*递归中只讨论最简要的情况，重复起来才会快(Version0中对左右子节点进行条件组合，会指数化增加程序规模)
3.！迭代实现递归，while+先进先出栈能实现递归的回溯过程


## Type/类型
# ---------------------------------------------

(1)series_sum
给出一个正整数N和长度L，找出一段长度大于等于L的连续非负整数，和为N。找出长度最小的那个。
输入描述:
输入数据包括一行： 两个正整数N(1 ≤ N ≤ 1000000000),L(2 ≤ L ≤ 100)
输出描述:
从小到大输出这段连续非负整数，以空格分隔，行末无空格。如果没有这样的序列或者找出的序列长度大于100，则输出No。
>Summary:
1.√map(Fun, Iterable_object) , 对可迭代对象重复运算；返回迭代器(只可往前迭代，迭代完成时引起StopIteration 异常。)  
2.√python遍历习惯从0开始  
3.注意python数值运算过程中自动对数据类型的扩展变换  
4.^ 是按位异或运算符，** 是幂运算符


### String/字符串
(3)length_of_longest_substring
给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。
>Summary:
1.滑动窗口动态规划
2.Python 的数组矩阵操作、Numpy--array、Pandas--Series,df
3.Python 字符串函数


(11)longest_palindrome
找出字符串s的最长回文字串。
>Summary:
1.！注意指针加偏移值的负值，边界以及尾部加一情况  #"ccb"
2.情况枚举的相互独立，相互穷尽  #"sooos"
3.range() 函数的某位设定（正负步长）


(20)valid_bracket
给出只含'(', ')', '{', '}', '[', ']'的字符串，要求左右括号按顺序闭合，验证字符串是否有效
>Summary:
1.字符串的删除
2.递归和栈


(647)!count_substring
给定一字符串s，计算其中有多少个回文子串。不同开始、结束位置被视为不同子串。
>Summary:
1.中心扩展算法√
2.!马拉车算法



(21)merge_two_list
将两个升序链表合并为一个升序链表，通过拼接给定结点组成。


(22)generate_parenthese
给定n，要求生成所有可能且有效的n对括号组合。


(23)merge_K_Lists
合并K个排序链表，返回新的排序链表。


(31)next_permutation


(32)longestvalidparenthese
给定一只包含'('和')'的字符串，找出最长有效括号子串长度
>Summary:
1.通过条件赋值语句(a = b if .. else c)在遍历过程中解决初始化的问题
2.运算符的优先级
3.！通过拒止栈解决连续字符串长度的问题
4.字符串翻转s[::-1]


(33)Search_flip_point_of_sorted_str
一升序数组在点某发生旋转，(如[0,1,4,5]变为[4,5,0,1])，假设数组无重复元素。
搜索发生旋转的索引，不存在则返回-1，要求时间复杂度O(log n)级别。


(34)Search_range
给定一升序整数数组nums，和目标值target。找出目标值在数组中的开始位置和结束位置。不存在则返回[-1,-1]。要求O(log n)级别。


(39)combination_sum
给定一无重复正整数元素数组和一目标数，找出数组中和为目标值的所有组合，数组的数字可以重复选取。


(42)trap
接雨水，给定n个非负整数表示宽度为1的柱形图，柱形紧靠，计算下雨后能接多少雨水。


(46)permute
给定一组无重复数字，返回所有可能的全排列。


(48)matrix_spin
给定一n×n二位矩阵，原地顺时针旋转90°返回，要求原地旋转，不另建矩阵。


(49)group_anagrams
给定一个字符串数组，将所有字母异位词(字母相同，排列不同)组合为一组返回。
例：
输入: ["eat", "tea", "tan", "ate", "nat", "bat"]
输出:
[
  ["ate","eat","tea"],
  ["nat","tan"],
  ["bat"]
]


(53)max_sub_array
给定一整数数组nums，找到一最大和的连续子数组(最少一个元素)，返回其最大和。


(55)can_jump
给定一非负整数数组，从第一位开始，元素的值代表该位置可以跳跃的最大长度，判断是否能到达最后一个位置。


(56)merge
给出一个区间集合，合并所有重叠的区间。
如：[[1,4],[4,5]]
返回：[[1,5]]


(62)unique_path
一机器人位于m×n矩阵的左上角，每次只能向下或向右移动一步。机器人有多少种路径到达右下角。


(64)min_path_sum
给定一非负整数的m×n矩阵，每次只能向下或向右移动一步。找出一条从左上角到右下角的路径，使得路径上的数字和最小。


(70)climb_stairs
给定一n阶楼梯，每次可爬1或2个台阶，有多少种不同方法爬到楼顶。


(72)min_distance
给定两个单词word1和word2，算出word1转换成word2的最少操作数。
允许进行三种操作：①插入一个字符；②删除一个字符；③替换一个字符


(75)sortcolors
给定一包含0，1，2的n元数组，原地对他们排序使得相同元素相邻且以0，1，2的顺序排序。


(76)min_window
给定字符串s，和t，在S中找出包含t所有(有可能重复)字符的最小字串。
没有则返回""；如果存在，则是唯一的。


(78)subset
给定一组不含重复元素的整数数组nums，返回该数组所有可能的子集。
例：nums=[1,2]
返回：[[1],[1,2],[2],[]]


(79)exist
给定一个二维网格和一个单词，通过相邻单元格按顺序查找，判断该字母是否存在于网格内。(同一单元格内的字母不重复使用)


(84)largers_rectangle_area
给定n个非负整数，表示并排的柱形高度，柱子宽度为1，求该柱形图中最大的矩形面积。


(85)maximal_rectangle
给定一个仅包含0、1的二维矩阵，找出只包含1的最大矩形并返回其面积。


(94)inorder_traversal
给定一个二叉树，返回他的中序遍历。


(96)num_trees
给定一整数n，求以1...n为节点组成的二叉搜索树有多少种？


(98)is_valid_BST
给定一个二叉树，判断其是否是一个有效的二叉搜索树
二叉搜索树的特征：①节点的左子树只包含小于当前节点的数；②节点的右子树只包含大于当前节点的数；③所有子树都是二叉搜索树


(101)issummetric_tree
给定一二叉树，检查它是否镜像对称。如[1,2,3,4,4,3]是对称的。


(102)level_order
给定一个二叉树，返回按层遍历(逐层遍历，从左往右)的所有节点。


(104)max_Depth
给定一二叉树，找出其最大深度(离根节点最远的叶节点距离)。


(105)build_tree
根据一棵树的前序遍历和中序遍历构造二叉树


(114)flatten
将二叉树按中序原地展开为单链表


(121)max_profit
给定一数组，第i个元素代表股票第i天的价格。只允许一次买入和卖出，算出利润最大的交易(卖出在买入前)。


(124)max_path_sum
给定一非空二叉树，返回其最大路径和。能从任意节点出发，到达任意点的序列。


(128)longest_consecutive
给定一未排序整数数组，找出最长连续序列的长度。要求TC为O(N)
#* 注意区分连续序列和连续数组


(136)single_number
给定一非空数组，有某个只出现一次的元素，其余每个元素都出现两次。找出那个元素，TC为O(N)且不使用额外的空间。


(139)word_break
给定一非空字符串s和包含非空无重复单词列表的字典wordDict，判定s是否可以拆分为一个或多个在字典出现的单词。(字典的单词可以重复使用)


(141)has_cycle
给定一链表，判断链表是否有环。有则返回该环开始的链表位置，否则返回-1。
进阶：要求SC为Ｏ(1)


(142)detect_cycle
给定一个链表，返回链表开始入环的第一个节点，无环则返回Null。不允许改定链表。
进阶：不使用额外空间。


(146)LRU_Cache
构建一个LRU缓存机制，支持数据的get(key)和put(key, value)功能。
get(key)时，关键字已存在则返回值，否则返回-1.
put(key, value)时，如果关键字已存在，则更改值；不存在则插入新值。缓存达到上限时，删除最久未使用的数据再插入新值。
进阶：TC为O(1)


(148)sort_list
在O(NlogN)TC和O(1)SC下对链表进行排序。


(152)max_product
给定一整数数组nums，找出数组中乘积最大的连续子数组(至少含一个数字)，返回该乘积。


(155)min_stack
设计一个支持push,pop,top,getMin操作的栈。要求检索最小元素TC为O(1)
push(x) -- 入栈
pop() -- 删除栈顶元素
top() -- 获取栈顶元素
getMin() -- 检索栈中最小元素


(160)get_intersection_node
查找两链表的相交节点(只有一个)


(169)majority_element
给定一个大小为n的非空数组，找到其中的多数元素(出现次数大于n/2的元素)


(200)!Islands_nums
给定一由"1"陆地和"0"水组成的二维网络(默认边界是水)，在水平垂直方向上相邻的陆地算为同一个岛。计算网格中岛屿的数量。


(206)reverse_list
翻转一个单链表


(207)!can_finish_lesson
某学期必须修n节课，其中有些课需要先修其他的课(正确的依赖关系形成单向无环图)。给定n和依赖课程的列表，确定能否完成所有的课程。


(208)Trie
实现一个前缀树，包含insert,search,startsWith三个操作


(215)find_Kth_largest
在未排序的数组中找到第k个最大的元素(含重复元素)。


(221)maximal_square
在一个由0和1组成的矩阵内找到之包含1的最大正方形，并返回其面积。


(226)invertTree
镜像翻转一棵二叉树


(234)is_palindrome_listnode
判断一个链表是否为回文链表


(236)lowest_common_ancestor
给定一二叉树，找到该树中两个指定节点的最近公共祖先(一个节点也能是自己的祖先)。


(238)product_except_self
给定一长度n>1的数组nums，返回一数组output。output[i]等于nums中除了nums[i]外其余元素的乘积。要求不能用除法。


(239)!max_sliding_window
给定一个数组nums，大小为k的滑动窗口从左至右移动，返回每次移动后窗口中的最大值。


(240)search_matrix
搜索m×n矩阵中是否有目标值target。矩阵元素从左至右，从上往下都是升序排列。


(279)num_squares
给定正整数n，找到若干个完全平方数(1,4,9,...)使得他们的和为n。要求完全平方数的个数最少。


(283)move_zeros
给定一个数组nums，将所有的0移到数组的末尾，同时保持非零元素的相对顺序。必须在原数组上操作。


(287)find_duplicate
给定一个n+1长整数数组nums，数字介于1到n之间，假设只有一个重复的整数，找出它。
要求原数组只读，使用O(n^2)时间和O(1)空间。


(297)！bin_tree_serialization
序列化是将对象转为可存储的比特位。设置一个算法序列化和反序列化二叉树。序列化输出的是字符串。


(300)longest_of_ascending_series
给定一无序整数数组，找出最长的上升子序列，返回其长度。


(301)!remove_invalid_parentheses
删除最小数量的无效括号，使得字符串合法，且返回所有可能的结果。
注：输入可能有除"("")"外的字符。


(309)max_profit
给定一整数数组，i元素代表第i天的股票价格。算出多次买入卖出后的最大利润。(卖出要在买入后，且两次买卖之间有一天的冻结期)


(312)max_coins
N个气球上标有不同的数字，存在数组nums中。戳破第i个气球后，将获得nums[left]*nums[i]*nums[right]个金币，求最终获得金币的最大值。
可以假设nums[-1]=nums[N]=1
注：戳爆气球i后，气球left和气球right就变为相邻气球。
0≤nums[i]≤100


(322)coin_change
给定不同面额的硬币数组coins和一个总金额amount。计算凑成总金额所需的最少硬币数(硬币可以重复使用)，不能凑成则返回-1。


(337)rob
小偷在一个地区行窃，房子连成一棵二叉树。相邻房子被偷则会触发警报。问小偷能偷到的最大金额。


(338)count_bits
给定一个非负整数num。对于0≤i≤num的所有数字i，计算其二进制数中的1出现次数，返回一个N+1长的计数数组。


(347)top_K_frequent
给定一个非空整数数组，返回出现频率前k高的元素数组。


(394)decode_string
给定一编码字符串，返回解码后的字符串。
编码规则为：k[encoded_string]，数字字符k表示encoded_string重复的次数。默认括号是符合格式的。


(399)calc_equation
方程式A/B=K,AB为字符串表示的变量，K为浮点数字。根据给定的已知方程和结果求解问题方程的解值。
描述示例：
给定 a / b = 2.0, b / c = 3.0
问题: a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? 
返回 [6.0, 0.5, -1.0, 1.0, -1.0 ]
输入示例：
equations(方程式) = [ ["a", "b"], ["b", "c"] ],
values(方程式结果) = [2.0, 3.0],
queries(问题方程式) = [ ["a", "c"], ["b", "a"], ["a", "e"], ["a", "a"], ["x", "x"] ]


(406)reconstruct_queue
假设打乱顺序的人站在一个队列里，每人由(h,k)表示。h表示身高，k表示排在前面且身高≥h的人数。重建出原队列。


(416)can_partition
给定一只含正整数的非空数组，是否可以将其分割成两个子集，使得子集的元素和相等。


(437)path_sum
给定一个二叉树，找出路径和等于给定数值的路径总数。(不需要从根节点开始，但方向必须向下)


(438)find_anagrams
给定一个字符串s和非空字符串p，找出s中所有p的字母异位词子串，返回其起始索引。


(448)find_disappeared_numbers
给定一范围[1,n](n为数组大小)的整数数组，数组中的元素只出现一次或两次，找出[1,n]中没出现的数字。


(461)hamming_distance
给出两个整数x和y，计算其二进制数的汉明距离。


(494)find_target_sum_ways
给定一非负整数数组an和目标数S。假定可以在任一整数上加上+或-。返回使得和为S的所有添加方法数。


(538)convert_BST
给定一二叉搜索树，将其转换为累加树，使得原节点值是原所有大于等于该节点值的和。


(543)diameter_of_binary_tree
给定一二叉树，计算其最大直径长度。即任意两节点路径长度的最大值。




### @Ali_test
(12)!num_of_permutations
给出Ｔ行数，每行为字符串长ｎ，问用小写字母能组合出多少种字符串，使得字符串中各子串的重复字母数不超过3。最后数目会很大，结果对＊＊取余。


(13)!robot_in_maze
机器人在迷宫中行走，从Ｓ处走往Ｅ处。指令为Ｆ前进，Ｌ左转，Ｒ右转，给出Ｔ组输入，第一行是ｈ，ｗ，ｎ；ｈ表示迷宫的行数，ｗ为迷宫的宽度，ｎ为命令行长度（命令行只有ＬＲ指令）。随后是ｈ行长为ｗ的字符串，“．＂表示可以通行，”＃“表示不能通行，且迷宫矩阵中只有一个Ｓ和Ｅ。允许在字符串的任意位置插入任意个Ｆ，问机器人能否到达终点。


(14)!regular_expression_matching
正则匹配：给一字符串s，和字符规律p，返回能否正则匹配。s，p只含有小写字母且可能为空。
'.'匹配任意字符，“\*”匹配零个或多个前一元素。
注：.\可替代所有字符串


### Sequence/序列 & Sort/排序
(10)!median_of_sorted_seqs
找出两个正序数列的中位数，要求时间复杂度不大于O(log(m+n))
>Summary:
1.二分法(k分法)实现对数级别的复杂度
2.设计算法关于空间复杂度的考量
3.√归并排序算法：通过等份划分再逐层排序，使得排序算法的时间复杂度从暴力枚举的O(N^2)降至O(NlogN)，空间复杂度为O(N);Python与Java的排序算法也是用基于归并排序的Timsort。
归并排序的核心，是每次排序归并记录了上一次排序的大小顺序(二叉树结构)，所以每次归并摸清的集合元素以两倍的规模上升。枚举排序由于没有保留每次排序的记录，所以重复的计算量很大。
4.python测试
5.程序的边界条件考虑
6.编程的逻辑结构
7.尾递归


(15)max_area
水桶容积：输入一正整数组，长为n≥2，代表坐标内各点上的垂线。找出其中两条线与x轴构成容器，使得容积最大。
输出容积。
注：容器不能倾斜
>>summary:
1.双指针法
2.python 的不可变对象lazy赋值，可变对象赋值


(16)threesum
三数之和：给出一个n整数数组nums，判断nums中是否存在三元素，使得a+b+c=0?找出所有满足条件且不重复的三元组。
输出：数组集合
>summary:
1.数组排序
2.数列取集合
3.！跳过嵌套循环的外层循环
4.√数组可以通过排序等方式实现组合查找
5.！定义变量名与内建函数重名会重载该关键字，覆盖原来的对象


(560)subarray_sum
给定一整数数组和整数k，找到该数组中和为k的连续子数组个数。
>Summary:
1.子数组之和可表示为前和减去后和
2.注意起始条件和k为0的特例


(581)find_unsorted_subarray
给定一整数数组，找出一连续子数组，如果对其升序排序，整个数组都会变成升序排序。返回其最短长度。
>Summary:
1.*不用厘清所有大小关系，只需要知道无序数组中最大最小值的正确位置
2.*用栈能实现极大/小值和最大/小值的快速比较




### Permutation/排列组合
(17)lettercombinations
给出一个2-9的字符串，返回所有它能表示的字母组合。数字到字母的映射与电话九宫格按键相同。
如：输入-“23”，输出-["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]


(18)remove_Nth_from_end
删除链表的倒数第N个节点：给出一链表，删除链表的第n个节点并返回其头节点。
如：
输入 - 1>>2>>3>>4>>5, n=2
输出 - 1>>2>>3>>5




### Queue/队列
*(621)least_interval
设置一个任务调度器。输入表示任务列表的字符串s以及同种任务(相同字符)间的冷却时间n。CPU能处理任务或待命，问完成所有任务的最短时间。
>Summary:
1.!贪心算法


## Data Structure
# ---------------------------------------------

### Stack/栈
(739)daily_temperatures
给定一气温列表，生成等长的列表。对应位置表示气温超过当日温度所需要的天数，若不存在则输入0。
>Summary:
1.无前效性(及只受最近值影响)的问题可用单调栈解决(先进后出)√
2.* python range() 的-1
3.* 先进先出栈可以以相反顺序(对于栈)解决问题


(2)Sum_of_two_num(Linked-list)
给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。
如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。
您可以假设除了数字0之外，这两个数都不会以0开头。
>Summary:
1.if-else 条件赋值语句的多种写法：
if a>b:
    c=a
else:
    c=b
------
c = a if a>b else b
------
c = [a,b][a>b]
------
c=(a>b and [a] or [b])[0]
2.√链表定义注意预保留首结点，否则更新指针容易丢失表头
3.def foobar(a:int, b:"it's b", c: str=5) -> tuple: 函数注解语法(Function Annotations)
获取注解有两种方法：
①foobar.__annotations__; ②import inspect, inspect.signature(foobar)
另，Python 解释器不会基于函数注解自动进行类型检查，类型检查需要自己实现。




## Database
# ---------------------------------------------